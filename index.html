<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Llega a la puerta segura - 20 Niveles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --btn-size-desktop: 60px;
      --btn-size-mobile: 90px;
    }
    body {
      background: #111;
      color: #fff;
      font-family: Arial, Helvetica, sans-serif;
      text-align: center;
      margin: 0;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation; /* reduce gestos extra√±os en m√≥vil */
    }
    h1 { margin: 10px; color: #ff0; }
    h2 { margin: 2px 0; font-weight: normal; }

    /* Lienzo */
    canvas {
      background: #222;
      display: block;
      margin: 10px auto;
      border: 3px solid #fff;
      border-radius: 10px;
      max-width: 98vw; /* para que nunca se salga en m√≥viles peque√±os */
      height: auto;    /* mantiene proporci√≥n */
    }

    /* Controles */
    .controls { margin-top: 10px; text-align: center; }
    .controls .row { display: flex; justify-content: center; align-items: center; }
    .controls button {
      width: var(--btn-size-desktop);
      height: var(--btn-size-desktop);
      margin: 6px;
      font-size: 24px;
      border-radius: 12px;
      border: none;
      background: #444;
      color: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,.4);
      cursor: pointer;
      transition: transform .08s ease;
      user-select: none;
    }
    .controls button:active { background: #888; transform: scale(.96); }

    /* Ranking */
    #ranking {
      margin: 16px auto 28px;
      padding: 12px 16px;
      border: 2px solid #ffd500;
      border-radius: 10px;
      display: inline-block;
      background: rgba(255, 213, 0, .06);
    }

    /* Overlay de mensajes (opcional, no bloquea) */
    #msg {
      position: fixed;
      left: 50%; top: 14%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.8);
      padding: 10px 16px;
      border-radius: 10px;
      color: #fff;
      font-size: 16px;
      display: none;
      z-index: 10;
      border: 1px solid #555;
    }

    /* üì± Responsivo m√≥vil */
    @media (max-width: 768px) {
      .controls { margin-top: 18px; }
      .controls button {
        width: var(--btn-size-mobile);
        height: var(--btn-size-mobile);
        font-size: 36px;
        margin: 10px;
      }
      #ranking { font-size: 18px; padding: 14px 18px; }
    }
  </style>
</head>
<body>
  <h1>‚ö° Llega a la puerta segura - 20 Niveles</h1>
  <h2 id="nivel">Nivel: 1</h2>
  <h2 id="vidas">Vidas: 3</h2>

  <canvas id="gameCanvas" width="900" height="600"></canvas>

  <div class="controls" aria-label="Controles t√°ctiles">
    <div class="row"><button id="btnUp" aria-label="Arriba">‚¨ÜÔ∏è</button></div>
    <div class="row">
      <button id="btnLeft" aria-label="Izquierda">‚¨ÖÔ∏è</button>
      <button id="btnDown" aria-label="Abajo">‚¨áÔ∏è</button>
      <button id="btnRight" aria-label="Derecha">‚û°Ô∏è</button>
    </div>
  </div>

  <div id="ranking">
    <h3>üèÜ Ranking de Tiempos</h3>
    <p id="tiempoActual">Tiempo actual: 0s</p>
    <p id="mejorTiempo">Mejor tiempo: -</p>
  </div>

  <div id="msg"></div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const CW = canvas.width, CH = canvas.height;

    // üü© Base segura
    const START_BASE = { x: 10, y: 10, w: 160, h: 130 };
    const BASE_BUFFER = 25; // margen extra para spawns
    const BASE_NO_SPAWN = expand(START_BASE, BASE_BUFFER);

    // Jugador y meta
    const player = { x: 0, y: 0, size: 25, color: "cyan", speed: 4 };
    const goal   = { x: CW - 50, y: CH - 50, size: 35, color: "red" };

    // Estado
    let level = 1;
    let vidas = 3;
    let invulnerableUntil = 0;

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    let walls = [];
    let enemies = [];

    // ‚è±Ô∏è Tiempo / ranking
    let startTime = Date.now();
    let tiempoActual = 0;
    let mejorTiempo = Number(localStorage.getItem("mejorTiempo") || 0) || null;

    setInterval(() => {
      tiempoActual = Math.floor((Date.now() - startTime) / 1000);
      document.getElementById("tiempoActual").textContent = "Tiempo actual: " + tiempoActual + "s";
      document.getElementById("mejorTiempo").textContent = "Mejor tiempo: " + (mejorTiempo ?? "-") + (mejorTiempo ? "s" : "");
    }, 1000);

    /* ---------- Utilidades ---------- */
    function rect(x,y,w,h){ return {x,y,w,h}; }
    function expand(r, pad){ return { x: r.x - pad, y: r.y - pad, w: r.w + pad*2, h: r.h + pad*2 }; }
    function intersects(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
    function aabb(o){ return { x:o.x, y:o.y, w:o.w||o.size, h:o.h||o.size }; }
    function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    function showMsg(text, ms=1400){
      const el = document.getElementById("msg");
      el.textContent = text;
      el.style.display = "block";
      clearTimeout(el._t);
      el._t = setTimeout(()=> el.style.display="none", ms);
    }

    function resetKeys(){
      for (const k in keys) keys[k] = false;
    }

    /* ---------- Generador de niveles (paredes separadas + enemigos fuera de la base) ---------- */
    const levels = [];
    for (let i = 1; i <= 20; i++) {
      const wallsLv = [];
      const enemiesLv = [];

      const wallCount = Math.min(6 + i * 2, 42);
      const lenMin = i < 6 ? 50 : i < 12 ? 80 : 120;
      const lenMax = i < 6 ? 110 : i < 12 ? 150 : 210;

      let tries = 0;
      while (wallsLv.length < wallCount && tries < wallCount * 30) {
        tries++;
        const horiz = Math.random() < 0.5;
        const len = randomInt(lenMin, lenMax);
        const w = horiz ? len : 20;
        const h = horiz ? 20 : len;

        const x = randomInt(40, CW - w - 40);
        const y = randomInt(40, CH - h - 40);
        const cand = rect(x,y,w,h);

        const GAP = 14;
        const candGap = expand(cand, GAP);
        if (intersects(candGap, BASE_NO_SPAWN)) continue;         // no tocar la base
        if (intersects(candGap, expand(aabb(goal), 12))) continue; // no tapar la meta

        let overlap = false;
        for (const ww of wallsLv){
          if (intersects(candGap, ww)){ overlap = true; break; }
        }
        if (!overlap) wallsLv.push(cand);
      }

      const enemyCount = Math.min(i, 12);
      for (let k = 0; k < enemyCount; k++) {
        let ex, ey;
        let guard = 0;
        while (true) {
          guard++; if (guard > 300) break;
          const ew = 25, eh = 25;
          ex = randomInt(40, CW - ew - 40);
          ey = randomInt(40, CH - eh - 40);
          const ebox = rect(ex,ey,ew,eh);
          if (intersects(ebox, BASE_NO_SPAWN)) continue;

          let hit = false;
          for (const w of wallsLv){ if (intersects(ebox, w)) { hit = true; break; } }
          if (!hit) break;
        }
        enemiesLv.push({
          x: ex, y: ey, w: 25, h: 25,
          dx: (Math.random()<0.5?-1:1)*(2 + i/5),
          dy: (Math.random()<0.5?-1:1)*(2 + i/5)
        });
      }
      levels.push({ walls: wallsLv, enemies: enemiesLv });
    }

    /* ---------- Carga / reinicio ---------- */
    function placePlayerAtBaseCenter(){
      player.x = START_BASE.x + (START_BASE.w - player.size)/2;
      player.y = START_BASE.y + (START_BASE.h - player.size)/2;
    }

    function loadLevel(lv){
      document.getElementById("nivel").textContent = "Nivel: " + lv;
      document.getElementById("vidas").textContent = "Vidas: " + vidas;

      walls = levels[lv-1].walls.map(w=>({...w}));
      enemies = levels[lv-1].enemies.map(e=>({...e}));

      placePlayerAtBaseCenter();
      invulnerableUntil = Date.now() + 1500; // 1.5s protecci√≥n
      resetKeys(); // evita ‚Äútecla pegada‚Äù al entrar al nivel
    }

    function resetGame(){
      level = 1;
      vidas = 3;
      startTime = Date.now();
      loadLevel(level);
      resetKeys();
    }

    function handleDeath(){
      vidas--;
      resetKeys(); // üîë soltar cualquier tecla activa
      if (vidas > 0) {
        showMsg("üí• Perdiste una vida. Vidas: " + vidas, 1200);
        loadLevel(level); // mismo nivel
      } else {
        showMsg("üíÄ Sin vidas. Reiniciando‚Ä¶", 1200);
        resetGame();
      }
    }

    /* ---------- Bucle ---------- */
    function update(){
      // Movimiento jugador con previsi√≥n de colisiones
      let nx = player.x, ny = player.y;
      if (keys.ArrowUp)    ny -= player.speed;
      if (keys.ArrowDown)  ny += player.speed;
      if (keys.ArrowLeft)  nx -= player.speed;
      if (keys.ArrowRight) nx += player.speed;

      // L√≠mites del lienzo
      nx = Math.max(0, Math.min(CW - player.size, nx));
      ny = Math.max(0, Math.min(CH - player.size, ny));

      // Bloqueo por paredes
      const nextBox = rect(nx, ny, player.size, player.size);
      let blocked = false;
      for (const w of walls){ if (intersects(nextBox, w)) { blocked = true; break; } }
      if (!blocked){ player.x = nx; player.y = ny; }

      // Enemigos movimiento y rebote
      for (const e of enemies){
        e.x += e.dx; e.y += e.dy;

        if (e.x <= 0 || e.x + e.w >= CW) e.dx *= -1;
        if (e.y <= 0 || e.y + e.h >= CH) e.dy *= -1;

        const eb = rect(e.x, e.y, e.w, e.h);
        // rebote con paredes
        for (const w of walls){
          if (intersects(eb, w)){
            const overlapX = Math.min(eb.x + eb.w, w.x + w.w) - Math.max(eb.x, w.x);
            const overlapY = Math.min(eb.y + eb.h, w.y + w.h) - Math.max(eb.y, w.y);
            if (overlapX < overlapY){ e.dx *= -1; e.x += Math.sign(e.dx) * 2; }
            else { e.dy *= -1; e.y += Math.sign(e.dy) * 2; }
          }
        }
        // enemigos no entran a la base
        if (intersects(eb, START_BASE)){
          const ox = Math.min(eb.x + eb.w, START_BASE.x + START_BASE.w) - Math.max(eb.x, START_BASE.x);
          const oy = Math.min(eb.y + eb.h, START_BASE.y + START_BASE.h) - Math.max(eb.y, START_BASE.y);
          if (ox < oy){ e.dx *= -1; e.x += Math.sign(e.dx) * 3; }
          else { e.dy *= -1; e.y += Math.sign(e.dy) * 3; }
        }

        // Colisi√≥n con jugador (si no est√° invulnerable)
        if (Date.now() >= invulnerableUntil && intersects(aabb(player), eb)){
          handleDeath();
          return;
        }
      }

      // Meta alcanzada
      if (intersects(aabb(player), aabb(goal))){
        if (level < levels.length){
          level++;
          showMsg("‚úÖ Nivel " + (level-1) + " superado");
          loadLevel(level);
        } else {
          const total = Math.floor((Date.now() - startTime)/1000);
          showMsg("üéâ ¬°Ganaste! Tiempo total: " + total + "s", 2200);
          if (!mejorTiempo || total < mejorTiempo){
            mejorTiempo = total;
            localStorage.setItem("mejorTiempo", String(mejorTiempo));
          }
          resetGame();
        }
      }
    }

    function draw(){
      ctx.clearRect(0,0,CW,CH);

      // Base segura
      ctx.fillStyle = "rgba(0,255,0,0.12)";
      ctx.fillRect(START_BASE.x, START_BASE.y, START_BASE.w, START_BASE.h);
      ctx.strokeStyle = "lime";
      ctx.lineWidth = 2;
      ctx.strokeRect(START_BASE.x, START_BASE.y, START_BASE.w, START_BASE.h);
      ctx.fillStyle = "lime";
      ctx.font = "14px Arial";
      ctx.fillText("BASE", START_BASE.x + 8, START_BASE.y + 18);

      // Meta (puerta roja)
      ctx.fillStyle = goal.color;
      ctx.fillRect(goal.x, goal.y, goal.size, goal.size);

      // Jugador
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.size, player.size);

      // Halo invulnerabilidad
      if (Date.now() < invulnerableUntil){
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 2;
        ctx.strokeRect(player.x - 3, player.y - 3, player.size + 6, player.size + 6);
      }

      // Paredes
      ctx.fillStyle = "gray";
      for (const w of walls) ctx.fillRect(w.x, w.y, w.w, w.h);

      // Enemigos
      ctx.fillStyle = "yellow";
      for (const e of enemies) ctx.fillRect(e.x, e.y, e.w, e.h);
    }

    function loop(){
      update();
      draw();
      requestAnimationFrame(loop);
    }

    /* ---------- Controles ---------- */
    document.addEventListener("keydown", e => {
      if (e.key in keys){ keys[e.key] = true; }
    });
    document.addEventListener("keyup", e => {
      if (e.key in keys){ keys[e.key] = false; }
    });

    // Reset de teclas en p√©rdida de foco/visibilidad (evita ‚Äútecla pegada‚Äù)
    window.addEventListener("blur", resetKeys);
    document.addEventListener("visibilitychange", () => { if (document.hidden) resetKeys(); });

    function bindBtn(btnId, key){
      const btn = document.getElementById(btnId);
      const on = e => { e.preventDefault(); keys[key] = true; };
      const off = e => { e.preventDefault(); keys[key] = false; };
      ["mousedown","touchstart"].forEach(ev => btn.addEventListener(ev, on, {passive:false}));
      ["mouseup","mouseleave","touchend","touchcancel"].forEach(ev => btn.addEventListener(ev, off, {passive:false}));
    }
    bindBtn("btnUp","ArrowUp");
    bindBtn("btnDown","ArrowDown");
    bindBtn("btnLeft","ArrowLeft");
    bindBtn("btnRight","ArrowRight");

    // Tambi√©n si el usuario suelta el dedo/click fuera del bot√≥n
    ["mouseup","touchend","touchcancel"].forEach(ev =>
      document.addEventListener(ev, resetKeys, {passive:false})
    );

    /* ---------- Inicio ---------- */
    function init(){
      // colocar jugador en base
      placePlayerAtBaseCenter();
      loadLevel(level);
      startTime = Date.now();
      loop();
    }
    init();
  </script>
</body>
</html>

